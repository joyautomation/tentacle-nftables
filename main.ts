/**
 * tentacle-nftables Service
 *
 * Manages nftables NAT rules via unified NatRule model.
 * Live state always from `nft` directly. Config persists as JSON +
 * generated nft syntax for boot-time loading.
 * Auto-manages IP aliases on interfaces via NATS requests to tentacle-network.
 *
 * Environment variables:
 *   NATS_SERVERS - NATS server URL(s), comma-separated (default: localhost:4222)
 *
 * Run with:
 *   deno run --allow-net --allow-read --allow-write=/etc/tentacle,/etc/nftables.d,/etc/sysctl.d --allow-env --allow-run=nft,sysctl main.ts
 */

import { connect, type NatsConnection } from "@nats-io/transport-deno";
import { jetstream } from "@nats-io/jetstream";
import { Kvm } from "@nats-io/kv";
import { enableNatsLogging, log as logMap } from "./src/utils/logger.ts";
import { getNftablesRuleset } from "./src/monitor/ruleset.ts";
import {
  readTentacleConfig,
  applyTentacleConfig,
} from "./src/commands/nftables.ts";
import { publishNftablesMetrics, slugify, getRuleKey } from "./src/metrics/publisher.ts";
import type {
  ServiceHeartbeat,
  NftablesStateMessage,
  NftablesCommandRequest,
  NftablesCommandResponse,
  NftablesConfig,
  NetworkCommandRequest,
  NetworkCommandResponse,
  NetworkStateMessage,
} from "@tentacle/nats-schema";
import { isNftablesCommandRequest } from "@tentacle/nats-schema";

// Access logMap.service dynamically so it picks up the wrapped logger after enableNatsLogging
const log = {
  get info() { return logMap.service.info.bind(logMap.service); },
  get warn() { return logMap.service.warn.bind(logMap.service); },
  get error() { return logMap.service.error.bind(logMap.service); },
  get debug() { return logMap.service.debug.bind(logMap.service); },
};

// ═══════════════════════════════════════════════════════════════════════════════
// NATS Connection with retry
// ═══════════════════════════════════════════════════════════════════════════════

async function connectToNats(servers: string): Promise<NatsConnection> {
  const serverList = servers.split(",").map((s) => s.trim());

  while (true) {
    try {
      log.info(`Connecting to NATS at ${servers}...`);
      const nc = await connect({ servers: serverList });
      log.info("Connected to NATS");
      return nc;
    } catch (err) {
      log.warn(`Failed to connect to NATS: ${err}. Retrying in 5 seconds...`);
      await new Promise((r) => setTimeout(r, 5000));
    }
  }
}

// ═══════════════════════════════════════════════════════════════════════════════
// IPv4 Forwarding
// ═══════════════════════════════════════════════════════════════════════════════

async function enableIpv4Forwarding(): Promise<void> {
  // Set immediately via sysctl
  const cmd = new Deno.Command("sysctl", {
    args: ["-w", "net.ipv4.ip_forward=1"],
    stdout: "piped",
    stderr: "piped",
  });
  const { code, stderr } = await cmd.output();
  if (code !== 0) {
    const errText = new TextDecoder().decode(stderr);
    log.warn(`Failed to enable ip_forward: ${errText}`);
  } else {
    log.info("Enabled net.ipv4.ip_forward=1");
  }

  // Persist for boot via sysctl.d drop-in
  try {
    await Deno.mkdir("/etc/sysctl.d", { recursive: true });
  } catch (err) {
    if (!(err instanceof Deno.errors.AlreadyExists)) throw err;
  }
  await Deno.writeTextFile(
    "/etc/sysctl.d/60-tentacle.conf",
    "# Generated by tentacle-nftables\nnet.ipv4.ip_forward = 1\n",
  );
}

// ═══════════════════════════════════════════════════════════════════════════════
// IP Alias Management
// ═══════════════════════════════════════════════════════════════════════════════

const MANAGED_ALIASES_PATH = "/etc/tentacle/managed-aliases.json";

interface ManagedAlias {
  iface: string;
  address: string; // CIDR, e.g. "10.0.0.100/24"
}

async function loadManagedAliases(): Promise<ManagedAlias[]> {
  try {
    const text = await Deno.readTextFile(MANAGED_ALIASES_PATH);
    return JSON.parse(text) as ManagedAlias[];
  } catch {
    return [];
  }
}

async function saveManagedAliases(aliases: ManagedAlias[]): Promise<void> {
  try {
    await Deno.mkdir("/etc/tentacle", { recursive: true });
  } catch (err) {
    if (!(err instanceof Deno.errors.AlreadyExists)) throw err;
  }
  await Deno.writeTextFile(MANAGED_ALIASES_PATH, JSON.stringify(aliases, null, 2) + "\n");
}

/**
 * Discover the prefix length for an interface by querying tentacle-network.
 * Falls back to /24 if unavailable.
 */
async function getInterfacePrefixLen(nc: NatsConnection, ifaceName: string): Promise<number> {
  try {
    const encoder = new TextEncoder();
    const decoder = new TextDecoder();
    const resp = await nc.request(
      "network.state",
      encoder.encode(JSON.stringify({ timestamp: Date.now() })),
      { timeout: 5000 },
    );
    const state: NetworkStateMessage = JSON.parse(decoder.decode(resp.data));
    const iface = state.interfaces.find((i) => i.name === ifaceName);
    if (iface) {
      const ipv4Addr = iface.addresses.find((a) => a.family === "inet");
      if (ipv4Addr) return ipv4Addr.prefixlen;
    }
  } catch {
    log.warn(`Could not query network state for prefix length of ${ifaceName}, using /24`);
  }
  return 24;
}

/**
 * Send an add-address or remove-address request to tentacle-network.
 */
async function sendAddressCommand(
  nc: NatsConnection,
  action: "add-address" | "remove-address",
  ifaceName: string,
  address: string,
): Promise<boolean> {
  try {
    const encoder = new TextEncoder();
    const decoder = new TextDecoder();
    const request: NetworkCommandRequest = {
      requestId: crypto.randomUUID(),
      action,
      interfaceName: ifaceName,
      address,
      timestamp: Date.now(),
    };
    const resp = await nc.request(
      "network.command",
      encoder.encode(JSON.stringify(request)),
      { timeout: 10000 },
    );
    const result: NetworkCommandResponse = JSON.parse(decoder.decode(resp.data));
    if (!result.success) {
      log.warn(`${action} ${address} on ${ifaceName} failed: ${result.error}`);
    }
    return result.success;
  } catch (err) {
    log.warn(`${action} ${address} on ${ifaceName} error: ${err}`);
    return false;
  }
}

/**
 * Compute required aliases from config, diff against tracked aliases,
 * add new ones and remove stale ones via tentacle-network.
 */
async function syncAliases(nc: NatsConnection, config: NftablesConfig): Promise<void> {
  const required: ManagedAlias[] = [];

  for (const rule of config.natRules) {
    if (!rule.enabled) continue;

    // natAddr alias on the incoming interface
    if (rule.natAddr && rule.incomingInterface) {
      const prefix = await getInterfacePrefixLen(nc, rule.incomingInterface);
      const cidr = rule.natAddr.includes("/") ? rule.natAddr : `${rule.natAddr}/${prefix}`;
      if (!required.some((a) => a.iface === rule.incomingInterface && a.address === cidr)) {
        required.push({ iface: rule.incomingInterface, address: cidr });
      }
    }

    // doubleNatAddr alias on the outgoing interface (only if custom address provided)
    if (rule.doubleNat && rule.doubleNatAddr && rule.outgoingInterface) {
      const prefix = await getInterfacePrefixLen(nc, rule.outgoingInterface);
      const cidr = rule.doubleNatAddr.includes("/") ? rule.doubleNatAddr : `${rule.doubleNatAddr}/${prefix}`;
      if (!required.some((a) => a.iface === rule.outgoingInterface && a.address === cidr)) {
        required.push({ iface: rule.outgoingInterface, address: cidr });
      }
    }
  }

  const previous = await loadManagedAliases();

  // Add new aliases
  for (const alias of required) {
    if (!previous.some((p) => p.iface === alias.iface && p.address === alias.address)) {
      log.info(`Adding alias ${alias.address} on ${alias.iface}`);
      await sendAddressCommand(nc, "add-address", alias.iface, alias.address);
    }
  }

  // Remove stale aliases
  for (const alias of previous) {
    if (!required.some((r) => r.iface === alias.iface && r.address === alias.address)) {
      log.info(`Removing stale alias ${alias.address} from ${alias.iface}`);
      await sendAddressCommand(nc, "remove-address", alias.iface, alias.address);
    }
  }

  await saveManagedAliases(required);
}

/**
 * On startup, re-apply all aliases for the current config (idempotent).
 */
async function reapplyAliases(nc: NatsConnection): Promise<void> {
  try {
    const config = await readTentacleConfig();
    await syncAliases(nc, config);
    log.info("Re-applied managed aliases on startup");
  } catch (err) {
    log.warn(`Failed to re-apply aliases on startup: ${err}`);
  }
}

// ═══════════════════════════════════════════════════════════════════════════════
// Main
// ═══════════════════════════════════════════════════════════════════════════════

async function main(): Promise<void> {
  log.info("═══════════════════════════════════════════════════════════════");
  log.info("            tentacle-nftables Service");
  log.info("═══════════════════════════════════════════════════════════════");

  const natsServers = Deno.env.get("NATS_SERVERS") || "localhost:4222";
  log.info(`Module ID: nftables`);
  log.info(`NATS Servers: ${natsServers}`);

  // Connect to NATS (retries forever)
  const nc = await connectToNats(natsServers);

  // Enable NATS log streaming for all loggers
  enableNatsLogging(nc, "nftables", "nftables");

  // Handle NATS connection close
  (async () => {
    const err = await nc.closed();
    if (err) {
      log.error(`NATS connection closed with error: ${err}`);
    }
  })();

  // Enable IPv4 forwarding (required for NAT to function)
  await enableIpv4Forwarding();

  // Re-apply managed IP aliases for current config (idempotent)
  await reapplyAliases(nc);

  const encoder = new TextEncoder();

  // ═══════════════════════════════════════════════════════════════════════════
  // Periodic config broadcasting (for GUI subscriptions)
  // ═══════════════════════════════════════════════════════════════════════════

  let lastRulesetError = false;

  async function publishNftablesState(): Promise<void> {
    try {
      const config = await readTentacleConfig();
      nc.publish(
        "nftables.rules",
        encoder.encode(JSON.stringify({
          moduleId: "nftables",
          timestamp: Date.now(),
          config,
        })),
      );

      // Publish individual metrics for MQTT bridge
      publishNftablesMetrics(nc, config);

      // Also try to read live ruleset for health tracking
      try {
        await getNftablesRuleset();
        if (lastRulesetError) {
          log.info("nft access restored");
          lastRulesetError = false;
        }
      } catch {
        if (!lastRulesetError) {
          log.warn("Cannot read nft ruleset (nft may not be available)");
          lastRulesetError = true;
        }
      }
    } catch (err) {
      log.warn(`Failed to publish nftables state: ${err}`);
    }
  }

  // Initial publish
  await publishNftablesState();
  log.info("Published initial nftables config");

  // Periodic publish every 10s
  const publishInterval = setInterval(publishNftablesState, 10_000);

  // ═══════════════════════════════════════════════════════════════════════════
  // On-demand live state request (request/reply — always fresh from nft)
  // ═══════════════════════════════════════════════════════════════════════════

  const stateSub = nc.subscribe("nftables.state");
  const stateAbort = new AbortController();

  (async () => {
    try {
      for await (const msg of stateSub) {
        if (stateAbort.signal.aborted) break;
        try {
          // Always read fresh — never serve stale data
          const rawRuleset = await getNftablesRuleset();
          const snapshot: NftablesStateMessage = {
            moduleId: "nftables",
            timestamp: Date.now(),
            rawRuleset,
          };
          msg.respond(encoder.encode(JSON.stringify(snapshot)));
        } catch (err) {
          msg.respond(
            encoder.encode(JSON.stringify({ error: String(err) })),
          );
        }
      }
    } catch (error) {
      if (!stateAbort.signal.aborted) {
        log.error("Error in state request handler:", error);
      }
    }
  })();

  log.info("Listening for state requests on: nftables.state");

  // ═══════════════════════════════════════════════════════════════════════════
  // Configuration commands (request/reply)
  // ═══════════════════════════════════════════════════════════════════════════

  const commandSub = nc.subscribe("nftables.command");
  const commandAbort = new AbortController();

  (async () => {
    try {
      for await (const msg of commandSub) {
        if (commandAbort.signal.aborted) break;
        try {
          const request = JSON.parse(
            new TextDecoder().decode(msg.data),
          ) as NftablesCommandRequest;

          if (!isNftablesCommandRequest(request)) {
            const resp: NftablesCommandResponse = {
              requestId:
                (request as Record<string, unknown>).requestId as string ??
                  "unknown",
              success: false,
              error: "Invalid command request",
              timestamp: Date.now(),
            };
            msg.respond(encoder.encode(JSON.stringify(resp)));
            continue;
          }

          log.info(`nftables command: ${request.action}`);

          if (request.action === "get-config") {
            const config = await readTentacleConfig();
            const resp: NftablesCommandResponse = {
              requestId: request.requestId,
              success: true,
              config,
              timestamp: Date.now(),
            };
            msg.respond(encoder.encode(JSON.stringify(resp)));
          } else if (request.action === "apply-config") {
            const config = {
              natRules: request.natRules ?? [],
            };

            // Manage IP aliases before applying nft rules
            await syncAliases(nc, config);

            const error = await applyTentacleConfig(config);
            const resp: NftablesCommandResponse = {
              requestId: request.requestId,
              success: error === null,
              error: error ?? undefined,
              timestamp: Date.now(),
            };
            msg.respond(encoder.encode(JSON.stringify(resp)));

            // After successful apply, re-publish state and metrics
            if (error === null) {
              await new Promise((r) => setTimeout(r, 1000));
              await publishNftablesState();
              publishNftablesMetrics(nc, config);
              log.info("Re-published nftables state after config apply");
            }
          }
        } catch (err) {
          const resp: NftablesCommandResponse = {
            requestId: "unknown",
            success: false,
            error: String(err),
            timestamp: Date.now(),
          };
          msg.respond(encoder.encode(JSON.stringify(resp)));
        }
      }
    } catch (error) {
      if (!commandAbort.signal.aborted) {
        log.error("Error in command handler:", error);
      }
    }
  })();

  log.info("Listening for commands on: nftables.command");

  // ═══════════════════════════════════════════════════════════════════════════
  // Individual field commands (from Sparkplug B DCMD routing)
  // ═══════════════════════════════════════════════════════════════════════════

  const fieldCommandSub = nc.subscribe("nftables.command.>");
  const fieldCommandAbort = new AbortController();

  (async () => {
    try {
      for await (const msg of fieldCommandSub) {
        if (fieldCommandAbort.signal.aborted) break;
        try {
          // Extract variableId from subject: nftables.command.{ruleKey}/{field}
          const variableId = msg.subject.slice("nftables.command.".length);

          // Parse ruleKey and field from variableId
          const slashIdx = variableId.lastIndexOf("/");
          if (slashIdx <= 0) {
            log.debug(`Ignoring field command with no field separator: ${variableId}`);
            continue;
          }
          const ruleKey = variableId.slice(0, slashIdx);
          const field = variableId.slice(slashIdx + 1);

          const rawValue = new TextDecoder().decode(msg.data);
          log.info(`Field command: ${variableId} = ${rawValue}`);

          // Read current config and find matching rule
          const config = await readTentacleConfig();
          const rule = config.natRules.find(
            (r) => getRuleKey(r) === ruleKey || r.id === ruleKey,
          );
          if (!rule) {
            log.warn(`No rule found for key: ${ruleKey}`);
            continue;
          }

          // Update the specific field
          switch (field) {
            case "enabled":
              rule.enabled = rawValue === "true" || rawValue === "1";
              break;
            case "protocol":
              rule.protocol = rawValue;
              break;
            case "connectingDevices":
              rule.connectingDevices = rawValue;
              break;
            case "incomingInterface":
              rule.incomingInterface = rawValue;
              break;
            case "outgoingInterface":
              rule.outgoingInterface = rawValue;
              break;
            case "natAddr":
              rule.natAddr = rawValue;
              break;
            case "originalPort":
              rule.originalPort = rawValue;
              break;
            case "translatedPort":
              rule.translatedPort = rawValue;
              break;
            case "deviceAddr":
              rule.deviceAddr = rawValue;
              break;
            case "deviceName":
              rule.deviceName = rawValue;
              break;
            case "doubleNat":
              rule.doubleNat = rawValue === "true" || rawValue === "1";
              break;
            case "doubleNatAddr":
              rule.doubleNatAddr = rawValue;
              break;
            case "comment":
              rule.comment = rawValue;
              break;
            default:
              log.warn(`Unknown nftables field: ${field}`);
              continue;
          }

          // Re-apply full config (aliases + nft rules)
          await syncAliases(nc, config);
          const error = await applyTentacleConfig(config);
          if (error) {
            log.error(`Failed to apply config for ${variableId}: ${error}`);
          } else {
            log.info(`Applied config change: ${variableId} = ${rawValue}`);
            await new Promise((r) => setTimeout(r, 1000));
            await publishNftablesState();
            publishNftablesMetrics(nc, config);
          }
        } catch (err) {
          log.error(`Error handling field command: ${err}`);
        }
      }
    } catch (error) {
      if (!fieldCommandAbort.signal.aborted) {
        log.error("Error in field command handler:", error);
      }
    }
  })();

  log.info("Listening for field commands on: nftables.command.>");

  // ═══════════════════════════════════════════════════════════════════════════
  // Heartbeat publishing for service discovery
  // ═══════════════════════════════════════════════════════════════════════════

  const js = jetstream(nc);
  const kvm = new Kvm(js);
  const heartbeatsKv = await kvm.create("service_heartbeats", {
    history: 1,
    ttl: 60 * 1000,
  });

  const heartbeatKey = "nftables";
  const startedAt = Date.now();

  const publishHeartbeat = async () => {
    const heartbeat: ServiceHeartbeat = {
      serviceType: "nftables",
      moduleId: "nftables",
      lastSeen: Date.now(),
      startedAt,
      metadata: {},
    };
    try {
      await heartbeatsKv.put(
        heartbeatKey,
        encoder.encode(JSON.stringify(heartbeat)),
      );
    } catch (err) {
      log.warn(`Failed to publish heartbeat: ${err}`);
    }
  };

  await publishHeartbeat();
  log.info("Service heartbeat started (moduleId: nftables)");

  const heartbeatInterval = setInterval(publishHeartbeat, 10000);

  log.info("");
  log.info("Service running. Press Ctrl+C to stop.");
  log.info("");

  // ═══════════════════════════════════════════════════════════════════════════
  // Graceful shutdown
  // ═══════════════════════════════════════════════════════════════════════════

  const shutdown = async (signal: string) => {
    log.info(`Received ${signal}, shutting down...`);

    clearInterval(publishInterval);
    clearInterval(heartbeatInterval);

    stateAbort.abort();
    commandAbort.abort();
    fieldCommandAbort.abort();

    try {
      await heartbeatsKv.delete(heartbeatKey);
      log.info("Removed service heartbeat");
    } catch {
      // Ignore - may already be expired
    }

    await nc.drain();
    log.info("Shutdown complete");
    Deno.exit(0);
  };

  Deno.addSignalListener("SIGINT", () => shutdown("SIGINT"));
  Deno.addSignalListener("SIGTERM", () => shutdown("SIGTERM"));

  // Listen for NATS shutdown command
  const shutdownSub = nc.subscribe("nftables.shutdown");
  (async () => {
    for await (const _msg of shutdownSub) {
      log.info("Received shutdown command via NATS");
      await shutdown("NATS shutdown");
      break;
    }
  })();
}

// Run
if (import.meta.main) {
  main().catch((err) => {
    log.error(`Fatal error: ${err}`);
    Deno.exit(1);
  });
}
