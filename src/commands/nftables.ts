/**
 * nftables configuration management.
 *
 * - Config stored as JSON at /etc/tentacle/nftables.json
 * - Generated nft syntax written to /etc/nftables.d/60-tentacle-nat.conf
 * - Applied atomically via `nft -f`
 *
 * Manages a dedicated `table ip tentacle_nat` — does NOT flush the
 * entire ruleset (preserves system filter rules).
 */

import type {
  NftablesConfig,
  NatRule,
} from "@tentacle/nats-schema";
import { log } from "../utils/logger.ts";

const logger = {
  get info() { return log.cmd.info.bind(log.cmd); },
  get debug() { return log.cmd.debug.bind(log.cmd); },
  get warn() { return log.cmd.warn.bind(log.cmd); },
  get error() { return log.cmd.error.bind(log.cmd); },
};

const CONFIG_PATH = "/etc/tentacle/nftables.json";
const NFT_CONF_PATH = "/etc/nftables.d/60-tentacle-nat.conf";

/**
 * Read the structured NAT config from disk.
 * Returns empty config if file doesn't exist.
 * Supports backward compat with old portForwards/snatRules format.
 */
export async function readTentacleConfig(): Promise<NftablesConfig> {
  try {
    const text = await Deno.readTextFile(CONFIG_PATH);
    const parsed = JSON.parse(text) as Record<string, unknown>;

    // New format: natRules array
    if (Array.isArray(parsed.natRules)) {
      return { natRules: parsed.natRules as NatRule[] };
    }

    // Legacy format: portForwards + snatRules (or masquerades)
    const portForwards = Array.isArray(parsed.portForwards) ? parsed.portForwards as Record<string, unknown>[] : [];
    const legacyMasquerades = Array.isArray(parsed.masquerades) ? parsed.masquerades as Record<string, unknown>[] : [];
    const snatRules = Array.isArray(parsed.snatRules)
      ? parsed.snatRules as Record<string, unknown>[]
      : legacyMasquerades.map((m) => ({ ...m, type: "masquerade" }));

    return { natRules: convertLegacyConfig(portForwards, snatRules) };
  } catch (err) {
    if (err instanceof Deno.errors.NotFound) {
      logger.debug("No config file found, returning empty config");
      return { natRules: [] };
    }
    throw err;
  }
}

/**
 * Convert old portForwards + snatRules into unified NatRule[].
 */
function convertLegacyConfig(
  portForwards: Record<string, unknown>[],
  snatRules: Record<string, unknown>[],
): NatRule[] {
  const rules: NatRule[] = [];
  const usedSnatGroupIds = new Set<string>();

  for (const pf of portForwards) {
    const groupId = pf.groupId as string | undefined;
    if (groupId) {
      const matchingSnat = snatRules.find((s) => s.groupId === groupId);
      if (matchingSnat) {
        usedSnatGroupIds.add(groupId);
        rules.push({
          id: groupId,
          enabled: pf.enabled as boolean ?? true,
          protocol: (pf.protocol as string) ?? "tcp",
          connectingDevices: "any",
          incomingInterface: (pf.interface as string) ?? "",
          outgoingInterface: (matchingSnat.interface as string) ?? "",
          natAddr: "",
          originalPort: String(pf.sourcePort ?? ""),
          translatedPort: String(pf.destPort ?? ""),
          deviceAddr: (pf.destAddr as string) ?? "",
          deviceName: "",
          doubleNat: true,
          doubleNatAddr: (matchingSnat.snatAddr as string) ?? "",
          comment: (pf.comment as string) ?? "",
        });
        continue;
      }
    }
    // Standalone DNAT
    rules.push({
      id: (pf.id as string) ?? crypto.randomUUID(),
      enabled: pf.enabled as boolean ?? true,
      protocol: (pf.protocol as string) ?? "tcp",
      connectingDevices: "any",
      incomingInterface: (pf.interface as string) ?? "",
      outgoingInterface: "",
      natAddr: "",
      originalPort: String(pf.sourcePort ?? ""),
      translatedPort: String(pf.destPort ?? ""),
      deviceAddr: (pf.destAddr as string) ?? "",
      deviceName: "",
      doubleNat: false,
      doubleNatAddr: "",
      comment: (pf.comment as string) ?? "",
    });
  }

  // Standalone SNAT rules without matching DNAT are discarded (masquerade dropped)
  return rules;
}

/**
 * Generate nft syntax from structured config.
 *
 * Produces an atomic ruleset that flushes and replaces only the
 * tentacle_nat table, preserving all other system rules.
 */
export function generateNftRules(config: NftablesConfig): string {
  const lines: string[] = [];

  lines.push("# Generated by tentacle-nftables — do not edit manually");
  lines.push("# Applied atomically via nft -f");
  lines.push("");

  // Delete existing table if present (ignore errors if it doesn't exist)
  lines.push("table ip tentacle_nat;");
  lines.push("delete table ip tentacle_nat;");
  lines.push("");

  lines.push("table ip tentacle_nat {");

  const enabledRules = config.natRules.filter((r) => r.enabled);

  // Prerouting chain (DNAT)
  lines.push("  chain prerouting {");
  lines.push("    type nat hook prerouting priority dstnat; policy accept;");

  for (const rule of enabledRules) {
    lines.push(`    ${formatNatRuleDnat(rule)}`);
  }

  lines.push("  }");
  lines.push("");

  // Postrouting chain (SNAT — only for doubleNat rules)
  const doubleNatRules = enabledRules.filter((r) => r.doubleNat);
  lines.push("  chain postrouting {");
  lines.push("    type nat hook postrouting priority srcnat; policy accept;");

  for (const rule of doubleNatRules) {
    lines.push(`    ${formatNatRuleSnat(rule)}`);
  }

  lines.push("  }");
  lines.push("}");
  lines.push("");

  return lines.join("\n");
}

function formatNatRuleDnat(rule: NatRule): string {
  const parts: string[] = [];

  // Source filter (connecting devices)
  if (rule.connectingDevices && rule.connectingDevices !== "any") {
    parts.push(`ip saddr ${rule.connectingDevices}`);
  }

  // Destination must be the NAT address (without this, ALL traffic on the interface gets DNATted)
  parts.push(`ip daddr ${rule.natAddr}`);

  // Protocol and port matching
  if (rule.protocol === "icmp") {
    parts.push("ip protocol icmp");
  } else if (rule.protocol === "tcp" || rule.protocol === "udp") {
    if (rule.originalPort) {
      parts.push(`${rule.protocol} dport ${rule.originalPort}`);
    }
  }
  // protocol "all" → no protocol filter

  // Incoming interface
  parts.push(`iifname "${rule.incomingInterface}"`);

  // DNAT target
  if (rule.protocol === "icmp" || rule.protocol === "all" || !rule.translatedPort) {
    parts.push(`dnat to ${rule.deviceAddr}`);
  } else {
    parts.push(`dnat to ${rule.deviceAddr}:${rule.translatedPort}`);
  }

  // Comment
  if (rule.comment) {
    parts.push(`comment "${rule.comment}"`);
  }

  return parts.join(" ");
}

function formatNatRuleSnat(rule: NatRule): string {
  const parts: string[] = [];

  // Match forwarded traffic destined for the device going out the outgoing interface
  parts.push(`ip daddr ${rule.deviceAddr}`);
  parts.push(`oifname "${rule.outgoingInterface}"`);

  // SNAT or masquerade
  if (rule.doubleNatAddr) {
    parts.push(`snat to ${rule.doubleNatAddr}`);
  } else {
    parts.push("masquerade");
  }

  if (rule.comment) {
    parts.push(`comment "${rule.comment}"`);
  }

  return parts.join(" ");
}

/**
 * Apply a NAT config: write JSON config, generate nft syntax, apply via nft -f.
 *
 * @returns null on success, error string on failure
 */
export async function applyTentacleConfig(
  config: NftablesConfig,
): Promise<string | null> {
  try {
    // Ensure config directory exists
    try {
      await Deno.mkdir("/etc/tentacle", { recursive: true });
    } catch (err) {
      if (!(err instanceof Deno.errors.AlreadyExists)) throw err;
    }

    // Ensure nftables.d directory exists
    try {
      await Deno.mkdir("/etc/nftables.d", { recursive: true });
    } catch (err) {
      if (!(err instanceof Deno.errors.AlreadyExists)) throw err;
    }

    // Write structured JSON config
    await Deno.writeTextFile(
      CONFIG_PATH,
      JSON.stringify(config, null, 2) + "\n",
    );
    logger.info(`Wrote config to ${CONFIG_PATH}`);

    // Generate nft syntax
    const nftRules = generateNftRules(config);
    await Deno.writeTextFile(NFT_CONF_PATH, nftRules);
    logger.info(`Wrote nft rules to ${NFT_CONF_PATH}`);

    // Apply via nft -f
    const cmd = new Deno.Command("nft", {
      args: ["-f", NFT_CONF_PATH],
      stdout: "piped",
      stderr: "piped",
    });

    const { code, stderr } = await cmd.output();

    if (code !== 0) {
      const errText = new TextDecoder().decode(stderr);
      const errMsg = `nft apply failed (exit ${code}): ${errText}`;
      logger.error(errMsg);
      return errMsg;
    }

    logger.info("Applied nftables config successfully");
    return null;
  } catch (err) {
    const errMsg = `Failed to apply nftables config: ${err}`;
    logger.error(errMsg);
    return errMsg;
  }
}
